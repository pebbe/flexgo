/* A lexical scanner generated by flexgo */

%#  Macros for preproc stage.
m4preproc_changecom

%# Macros for runtime processing stage.
m4_changecom
m4_changequote
m4_changequote([[, ]])

%% [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here

%% [1.5] DFA

%% [2.0] code to fiddle yytext and yyleng for yymore() goes here

%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array

%% [4.0] data tables for the DFA go here

%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++

%% [6.0] YY_RULE_SETUP definition goes here
func YYlex() {
	if !yy_init {
		yy_init = true

		// #ifdef YY_USER_INIT
		// YY_USER_INIT
		// #endif

		if yy_start == 0 {
			yy_start = 1 /* first start state */
		}

		if YYin == nil {
			YYin = os.Stdin
		}

		if YYout == nil {
			YYout = os.Stdout
		}

		if yy_buffer_stack == nil {
			yy_buffer_stack = make([]*yy_buffer_state, 1)
			yy_buffer_stack[0] = yy_create_buffer(YYin)
			yy_buffer_stack_top = 0
		}
	}

	{
%% [7.0] user's declarations go here

		var yy_act, yy_last_accepting_state, yy_last_accepting_cpos int
		for { /* loops until end-of-file is reached */
			var bytes []byte
			var unused int

			buffer := yy_buffer_stack[yy_buffer_stack_top]

			var yy_current_state int
			dont := false
			if dont {
				goto yy_match
			}
			if dont {
				goto yy_find_action
			}
			if dont {
				goto do_action
			}
%% [8.0] yymore()-related code goes here

%% [9.0] code to set up and find next match goes here

%% [10.0] code to find the action number goes here

%% [11.0] code for yylineno update goes here

%% [12.0] debug code goes here

%% [13.0] actions go here

%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here

%% [15.0] code to get the start state into yy_current_state goes here

%% [16.0] code to find the next state goes here

%% [17.0] code to find the next state, and perhaps do backing up, goes here

%% [18.0] update yylineno here

%% [19.0] update BOL and yylineno


func YYmain(filenames ...string) {

	if len(filenames) == 0 {
		YYin = os.Stdin
 	} else {
                r, err := os.Open(filenames[0])
                if err != nil {
                        log.Fatal(err)
                }
                YYin = r // YYrestart(r) ???
                YYwrap = func() bool {
                        r.Close()
                        filenames = filenames[1:]
                        if len(filenames) == 0 {
                                return true
                        }
                        r, err = os.Open(filenames[0])
                        YYrestart(r)
                        if err != nil {
                                log.Fatal(err)
                        }
                        return false
                }
        }

        YYlex()
}
