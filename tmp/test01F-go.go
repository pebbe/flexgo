package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
)

// return type of yy.Flex()
type YYtype interface{}

// returned on end of file
var YYnull YYtype = nil

// START OF SKELL ------------------------------------------------------
// A lexical scanner generated by flexgo

type Scanner struct {
	In   io.Reader
	Out  io.Writer
	Text []byte
	Leng int

	Filename      string
	UserData      interface{}
	UserAction    func(*Scanner)
	Wrap          func(*Scanner) bool
	IsInteractive func(io.Reader) bool

	lastAcceptingState   int
	lastAcceptingCpos    int
	debug                bool
	start                int
	stateBuf             []int
	statePtr             int
	currentState         int
	fullState            int
	fullMatch            int
	fullLp               int
	lp                   int
	cp, bp               int
	act                  int
	holdChar             byte
	cBufP                int
	didBufferSwitchOnEof bool
	textPtr              int
	nChars               int
	init                 bool
	moreFlag             bool
	moreLen              int

	// buffer
	inputFile    io.Reader
	chBuf        []byte // input buffer
	bufPos       int    // current position in input buffer
	bufSize      int
	bufNChars    int
	Interactive  bool
	atBol        int // 0 (falase) or 1 (true)
	fillBuffer   bool
	bufferStatus int
}

func NewScanner() *Scanner {
	yy := Scanner{

		Wrap:          func(yyy *Scanner) bool { return true },
		IsInteractive: func(file io.Reader) bool { return yyInteractiveDefault },
		bufSize:       yyBufSize,
		chBuf:         make([]byte, yyBufSize+2),
		start:         1,
		stateBuf:      make([]int, 0),
		atBol:         1,
		debug:         yyFlexDebug,
		fillBuffer:    true,
	}
	return &yy
}

func (yy *Scanner) NewFile() {
	yy.Restart(yy.In)
}

const yyEndOfBufferChar = 0

const yyBufSize = 32768

const (
	eobActEndOfFile    = 0
	eobActContinueScan = 1
	eobActLastMatch    = 2
)

const (
	yyBufferNew        = 0
	yyBufferNormal     = 1
	yyBufferEofPending = 2
)

// [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
/* %% [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
/* Begin user sect3 */
const yyFlexDebug = true

const yyInteractiveDefault = false

// SKEL ----------------------------------------------------------------

// [1.5] DFA------------------------------------------------------------
/* %% [1.5] DFA */
// SKEL ----------------------------------------------------------------

func (yy *Scanner) doBeforeAction() {
	yy.textPtr = yy.bp

	// [2.0] code to fiddle yytext and yyleng for yy''more() goes here -------
	/* %% [2.0] code to fiddle yytext and yyleng for yy''more() goes here */
	yy.Leng = yy.cp - yy.bp
	// SKEL ----------------------------------------------------------------

	yy.holdChar = yy.chBuf[yy.cp]
	yy.chBuf[yy.cp] = 0

	// [3.0] code to copy yytext_ptr to yytext[] goes here, if %array ------
	/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array */
	// SKEL ----------------------------------------------------------------

	yy.cBufP = yy.cp
	yy.Text = yy.chBuf[yy.textPtr:yy.cp]
}

// [4.0] data tables for the DFA go here -------------------------------
/* %% [4.0] data tables for the DFA go here */
const yyNumRules = 4
const yyEndOfBuffer = 5

type yyTransInfo struct {
	yyVerify int16
	yyNxt    int16
}

var yyTransition = [1046]yyTransInfo{
	{0, 0}, {0, 790}, {0, 0}, {0, 788}, {1, 516},
	{2, 516}, {3, 516}, {4, 516}, {5, 516}, {6, 516},
	{7, 516}, {8, 516}, {9, 516}, {10, 516}, {11, 516},
	{12, 516}, {13, 516}, {14, 516}, {15, 516}, {16, 516},
	{17, 516}, {18, 516}, {19, 516}, {20, 516}, {21, 516},
	{22, 516}, {23, 516}, {24, 516}, {25, 516}, {26, 516},
	{27, 516}, {28, 516}, {29, 516}, {30, 516}, {31, 516},
	{32, 516}, {33, 516}, {34, 516}, {35, 516}, {36, 516},
	{37, 516}, {38, 516}, {39, 516}, {40, 516}, {41, 516},
	{42, 516}, {43, 516}, {44, 516}, {45, 516}, {46, 516},

	{47, 516}, {48, 516}, {49, 516}, {50, 516}, {51, 516},
	{52, 516}, {53, 516}, {54, 516}, {55, 516}, {56, 516},
	{57, 516}, {58, 516}, {59, 516}, {60, 516}, {61, 516},
	{62, 516}, {63, 516}, {64, 516}, {65, 516}, {66, 516},
	{67, 518}, {68, 516}, {69, 516}, {70, 516}, {71, 516},
	{72, 516}, {73, 516}, {74, 516}, {75, 516}, {76, 516},
	{77, 516}, {78, 516}, {79, 516}, {80, 516}, {81, 516},
	{82, 516}, {83, 516}, {84, 516}, {85, 516}, {86, 516},
	{87, 516}, {88, 516}, {89, 516}, {90, 516}, {91, 516},
	{92, 516}, {93, 516}, {94, 516}, {95, 516}, {96, 516},

	{97, 516}, {98, 520}, {99, 516}, {100, 516}, {101, 516},
	{102, 522}, {103, 516}, {104, 516}, {105, 516}, {106, 516},
	{107, 516}, {108, 516}, {109, 516}, {110, 516}, {111, 516},
	{112, 516}, {113, 516}, {114, 516}, {115, 516}, {116, 516},
	{117, 516}, {118, 516}, {119, 516}, {120, 516}, {121, 516},
	{122, 516}, {123, 516}, {124, 516}, {125, 516}, {126, 516},
	{127, 516}, {128, 516}, {129, 516}, {130, 516}, {131, 516},
	{132, 516}, {133, 516}, {134, 516}, {135, 516}, {136, 516},
	{137, 516}, {138, 516}, {139, 516}, {140, 516}, {141, 516},
	{142, 516}, {143, 516}, {144, 516}, {145, 516}, {146, 516},

	{147, 516}, {148, 516}, {149, 516}, {150, 516}, {151, 516},
	{152, 516}, {153, 516}, {154, 516}, {155, 516}, {156, 516},
	{157, 516}, {158, 516}, {159, 516}, {160, 516}, {161, 516},
	{162, 516}, {163, 516}, {164, 516}, {165, 516}, {166, 516},
	{167, 516}, {168, 516}, {169, 516}, {170, 516}, {171, 516},
	{172, 516}, {173, 516}, {174, 516}, {175, 516}, {176, 516},
	{177, 516}, {178, 516}, {179, 516}, {180, 516}, {181, 516},
	{182, 516}, {183, 516}, {184, 516}, {185, 516}, {186, 516},
	{187, 516}, {188, 516}, {189, 516}, {190, 516}, {191, 516},
	{192, 516}, {193, 516}, {194, 516}, {195, 516}, {196, 516},

	{197, 516}, {198, 516}, {199, 516}, {200, 516}, {201, 516},
	{202, 516}, {203, 516}, {204, 516}, {205, 516}, {206, 516},
	{207, 516}, {208, 516}, {209, 516}, {210, 516}, {211, 516},
	{212, 516}, {213, 516}, {214, 516}, {215, 516}, {216, 516},
	{217, 516}, {218, 516}, {219, 516}, {220, 516}, {221, 516},
	{222, 516}, {223, 516}, {224, 516}, {225, 516}, {226, 516},
	{227, 516}, {228, 516}, {229, 516}, {230, 516}, {231, 516},
	{232, 516}, {233, 516}, {234, 516}, {235, 516}, {236, 516},
	{237, 516}, {238, 516}, {239, 516}, {240, 516}, {241, 516},
	{242, 516}, {243, 516}, {244, 516}, {245, 516}, {246, 516},

	{247, 516}, {248, 516}, {249, 516}, {250, 516}, {251, 516},
	{252, 516}, {253, 516}, {254, 516}, {255, 516}, {256, 516},
	{0, 0}, {0, 530}, {1, 258}, {2, 258}, {3, 258},
	{4, 258}, {5, 258}, {6, 258}, {7, 258}, {8, 258},
	{9, 258}, {10, 258}, {11, 258}, {12, 258}, {13, 258},
	{14, 258}, {15, 258}, {16, 258}, {17, 258}, {18, 258},
	{19, 258}, {20, 258}, {21, 258}, {22, 258}, {23, 258},
	{24, 258}, {25, 258}, {26, 258}, {27, 258}, {28, 258},
	{29, 258}, {30, 258}, {31, 258}, {32, 258}, {33, 258},
	{34, 258}, {35, 258}, {36, 258}, {37, 258}, {38, 258},

	{39, 258}, {40, 258}, {41, 258}, {42, 258}, {43, 258},
	{44, 258}, {45, 258}, {46, 258}, {47, 258}, {48, 258},
	{49, 258}, {50, 258}, {51, 258}, {52, 258}, {53, 258},
	{54, 258}, {55, 258}, {56, 258}, {57, 258}, {58, 258},
	{59, 258}, {60, 258}, {61, 258}, {62, 258}, {63, 258},
	{64, 258}, {65, 258}, {66, 258}, {67, 260}, {68, 258},
	{69, 258}, {70, 258}, {71, 258}, {72, 258}, {73, 258},
	{74, 258}, {75, 258}, {76, 258}, {77, 258}, {78, 258},
	{79, 258}, {80, 258}, {81, 258}, {82, 258}, {83, 258},
	{84, 258}, {85, 258}, {86, 258}, {87, 258}, {88, 258},

	{89, 258}, {90, 258}, {91, 258}, {92, 258}, {93, 258},
	{94, 258}, {95, 258}, {96, 258}, {97, 258}, {98, 262},
	{99, 258}, {100, 258}, {101, 258}, {102, 264}, {103, 258},
	{104, 258}, {105, 258}, {106, 258}, {107, 258}, {108, 258},
	{109, 258}, {110, 258}, {111, 258}, {112, 258}, {113, 258},
	{114, 258}, {115, 258}, {116, 258}, {117, 258}, {118, 258},
	{119, 258}, {120, 258}, {121, 258}, {122, 258}, {123, 258},
	{124, 258}, {125, 258}, {126, 258}, {127, 258}, {128, 258},
	{129, 258}, {130, 258}, {131, 258}, {132, 258}, {133, 258},
	{134, 258}, {135, 258}, {136, 258}, {137, 258}, {138, 258},

	{139, 258}, {140, 258}, {141, 258}, {142, 258}, {143, 258},
	{144, 258}, {145, 258}, {146, 258}, {147, 258}, {148, 258},
	{149, 258}, {150, 258}, {151, 258}, {152, 258}, {153, 258},
	{154, 258}, {155, 258}, {156, 258}, {157, 258}, {158, 258},
	{159, 258}, {160, 258}, {161, 258}, {162, 258}, {163, 258},
	{164, 258}, {165, 258}, {166, 258}, {167, 258}, {168, 258},
	{169, 258}, {170, 258}, {171, 258}, {172, 258}, {173, 258},
	{174, 258}, {175, 258}, {176, 258}, {177, 258}, {178, 258},
	{179, 258}, {180, 258}, {181, 258}, {182, 258}, {183, 258},
	{184, 258}, {185, 258}, {186, 258}, {187, 258}, {188, 258},

	{189, 258}, {190, 258}, {191, 258}, {192, 258}, {193, 258},
	{194, 258}, {195, 258}, {196, 258}, {197, 258}, {198, 258},
	{199, 258}, {200, 258}, {201, 258}, {202, 258}, {203, 258},
	{204, 258}, {205, 258}, {206, 258}, {207, 258}, {208, 258},
	{209, 258}, {210, 258}, {211, 258}, {212, 258}, {213, 258},
	{214, 258}, {215, 258}, {216, 258}, {217, 258}, {218, 258},
	{219, 258}, {220, 258}, {221, 258}, {222, 258}, {223, 258},
	{224, 258}, {225, 258}, {226, 258}, {227, 258}, {228, 258},
	{229, 258}, {230, 258}, {231, 258}, {232, 258}, {233, 258},
	{234, 258}, {235, 258}, {236, 258}, {237, 258}, {238, 258},

	{239, 258}, {240, 258}, {241, 258}, {242, 258}, {243, 258},
	{244, 258}, {245, 258}, {246, 258}, {247, 258}, {248, 258},
	{249, 258}, {250, 258}, {251, 258}, {252, 258}, {253, 258},
	{254, 258}, {255, 258}, {256, 258}, {0, 4}, {0, 272},
	{0, 3}, {0, 270}, {0, 4}, {0, 268}, {0, 4},
	{0, 266}, {0, 0}, {0, 264}, {0, 0}, {0, 262},
	{0, 2}, {0, 260}, {0, 1}, {0, 258}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},

	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},

	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{97, 4}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {111, 4}, {0, 0}, {0, 0}, {0, 0},
	{111, 4}, {114, 4}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},

	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},

	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},

	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0},
	{257, 5}, {1, 0}}

var yyStartStateList = [3]int{
	1, 3, 261,
}

var yyRuleLinenum = [4]int16{0,
	23, 25, 27,
}

// SKEL ----------------------------------------------------------------

const yyInitial = 0

const yyReadBufSize = 16384

func (yy *Scanner) Echo() {
	yy.Out.Write(yy.Text)
}

func (yy *Scanner) input(offset, maxRead int) int {

	// [5.0] fread()/read() definition of yy_INPUT goes here ---------------
	/* %% [5.0] fread()/read() definition of yy_INPUT goes here */
	// nothing here, all moved to skeleton
	// SKEL ----------------------------------------------------------------

	if yy.Interactive {
		b := make([]byte, 1)
		var n int
		for n = 0; n < maxRead; n++ {
			nn, err := yy.inputFile.Read(b)
			if nn < 1 {
				if err != nil && err != io.EOF {
					log.Panicln("input in flex scanner failed:", err)
				}
				break
			}
			yy.chBuf[offset+n] = b[0]
			if b[0] == '\n' {
				n++
				break
			}
		}
		return n
	}

	b := make([]byte, maxRead)
	n, err := yy.inputFile.Read(b)
	if err != nil && err != io.EOF {
		log.Panicln("input in flex scanner failed:", err)
	}
	copy(yy.chBuf[offset:], b[:n])
	//for i := 0; i < n; i++ {
	//	yy.chBuf[offset+i] = b[i]
	//}
	return n
}

/* %if-tables-serialization structures and prototypes */
/* %endif */

// TODO: The bison pure parser, flex.skl line 1231-1250

/* [6.0] YY_RULE_SETUP definition goes here --------------------------*/
/* %% [6.0] YY_RULE_SETUP definition goes here */

// SKEL ----------------------------------------------------------------

func (yy *Scanner) Less(n int) {
	// Undo effects of setting up yytext.
	yyless_macro_arg := n

	yy.chBuf[yy.cBufP] = yy.holdChar

	yy.cp = yy.bp + yyless_macro_arg - 0
	yy.cBufP = yy.cp
	yy.doBeforeAction()
}

// The main scanner function which does all the work.
func (yy *Scanner) Lex() YYtype {

	if !yy.init {
		yy.init = true
		if yy.In == nil {
			yy.In = os.Stdin
		}
		if yy.Out == nil {
			yy.Out = os.Stdout
		}
		yy.initBuffer(yy.In)
		yy.loadBufferState()
	}

	var yytext []byte
	var yyleng int

	yyout := yy.Out
	if false {
		fmt.Print(yytext, yyleng, yyout)
	}

	// [7.0] user's declarations go here -----------------------------------
	/* %% [7.0] user''s declarations go here */

	// SKEL ----------------------------------------------------------------

	for { // loops until end-of-file is reached

		// [8.0] yy''more-related code goes here -------------------------------
		/* %% [8.0] yy''more-related code goes here */
		// SKEL ----------------------------------------------------------------

		yy.cp = yy.cBufP

		/* Support of yytext. */
		yy.chBuf[yy.cp] = yy.holdChar

		// yy.bp points to the position in yy_ch_buf of the start of
		// the current run.
		yy.bp = yy.cp

		// [9.0] code to set up and find next match goes here ------------------
		/* %% [9.0] code to set up and find next match goes here */
		yy.currentState = yyStartStateList[yy.start]
	yyMatch:
		yyC := yy.chBuf[yy.cp]
		for {
			transInfo := yy.Transition[yy.currentState+yyC]
			if int(transInfo.yyVerify) != int(yyC) {
				break
			}
			yy.cp++
			yyC = yy.chBuf[yy.cp]
			yy.currentState += int(transInfo.yyNxt)
			if yy.Transition[yy.currentState-1].yyNxt != 0 {
				yy.lastAcceptingState = yy.currentState
				yy.lastAcceptingCpos = yy.cp
			}
		}
		// SKEL ----------------------------------------------------------------

	yyFindAction:

		// [10.0] code to find the action number goes here ---------------------
		/* %% [10.0] code to find the action number goes here */
		yy.act = yy.currentState[-1].yy_nxt
		// SKEL ----------------------------------------------------------------

		yy.doBeforeAction()

		// [11.0] code for yylineno update goes here ---------------------------
		/* %% [11.0] code for yylineno update goes here */

		// SKEL ----------------------------------------------------------------

	doAction: // This label is used only to access EOF actions.

		// [12.0] debug code goes here -----------------------------------------
		/* %% [12.0] debug code goes here */
		if yyFlexDebug {
			if yy.act == 0 {
				fmt.Fprintln(os.Stderr, "--scanner backing up")
			} else if yy.act < 4 {
				fmt.Fprintf(os.Stderr, "--accepting rule at line %d (%q)\n",
					yyRuleLinenum[yy.act], yy.Text)
			} else if yy.act == 4 {
				fmt.Fprintf(os.Stderr, "--accepting default rule (%q)\n", yy.Text)
			} else if yy.act == 5 {
				fmt.Fprintln(os.Stderr, "--(end of buffer or a NUL)")
			} else {
				fmt.Fprintf(os.Stderr, "--EOF (start condition %d)\n", ((yy.start - 1) / 2))
			}
		}
		// SKEL ----------------------------------------------------------------

		switch yy.act { // beginning of action switch

		// [13.0] actions go here ----------------------------------------------
		/* %% [13.0] actions go here */
		case 0: // must back up
			// undo the effects of yy_DO_BEFORE_ACTION
			yy.chBuf[yy.cp] = yy.holdChar
			yy.cp = yy.lastAcceptingCpos + 1
			yy.currentState = yy.lastAcceptingState
			goto yyFindAction

		case 1:
			fallthrough
		case 2:

			if yy.UserAction != nil {
				yy.UserAction(yy)
			}
			yytext = yy.Text
			yyleng = yy.Leng

			yyout.Write(bytes.ToUpper(yytext))
		case 3:

			if yy.UserAction != nil {
				yy.UserAction(yy)
			}
			yytext = yy.Text
			yyleng = yy.Leng

			yyout.Write([]byte("Go"))
		case 4:

			if yy.UserAction != nil {
				yy.UserAction(yy)
			}
			yytext = yy.Text
			yyleng = yy.Leng

			yy.Echo()
		case (yyEndOfBuffer + yyInitial + 1):
			return YYnull
			// SKEL ----------------------------------------------------------------

		case yyEndOfBuffer:
			/* Amount of text matched not including the EOB char. */
			yyAmountOfMatchedText := yy.cp - yy.textPtr - 1

			/* Undo the effects of yy_DO_BEFORE_ACTION. */
			yy.chBuf[yy.cp] = yy.holdChar

			if yy.bufferStatus == yyBufferNew {
				/* We're scanning a new file or input source.  It's
				 * possible that this happened because the user
				 * just pointed yyin at a new source and called
				 * yylex().  If so, then we have to assure
				 * consistency between yy_CURRENT_BUFFER and our
				 * globals.  Here is the right place to do so, because
				 * this is the first action (other than possibly a
				 * back-up) that will match for the new input source.
				 */
				yy.nChars = yy.bufNChars
				yy.inputFile = yy.In
				yy.bufferStatus = yyBufferNormal
			}

			/* Note that here we test for yy_c_buf_p "<=" to the position
			 * of the first EOB in the buffer, since yy_c_buf_p will
			 * already have been incremented past the NUL character
			 * (since all states make transitions on EOB to the
			 * end-of-buffer state).  Contrast this with the test
			 * in input().
			 */
			if yy.cBufP <= yy.nChars {
				/* This was really a NUL. */
				var yyNextState int

				yy.cBufP = yy.textPtr + yyAmountOfMatchedText

				yy.currentState = yy.getPreviousState()

				/* Okay, we're now positioned to make the NUL
				 * transition.  We couldn't have
				 * yy_get_previous_state() go ahead and do it
				 * for us because it doesn't know how to deal
				 * with the possibility of jamming (and we don't
				 * want to build jamming into it because then it
				 * will run more slowly).
				 */

				yyNextState = yy.tryNulTrans(yy.currentState)

				yy.bp = yy.textPtr + 0

				if yyNextState != 0 {
					/* Consume the NUL. */
					yy.cBufP++
					yy.cp = yy.cBufP
					yy.currentState = yyNextState
					goto yyMatch
				} else {

					// [14.0] code to do back-up for compressed tables and set up yy_cp goes here
					/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
					yy.cp = yy.cBufP
					// SKEL ----------------------------------------------------------------

					goto yyFindAction
				}

			} else {

				switch yy.getNextBuffer() {
				case eobActEndOfFile:
					yy.didBufferSwitchOnEof = false

					if yy.Wrap(yy) {
						// Note: because we've taken care in
						// yy_get_next_buffer() to have set up
						// yytext, we can now set up
						// yy.cBufP so that if some total
						// hoser (like flex itself) wants to
						// call the scanner after we return the
						// yy_NULL, it'll still work - another
						// yy_NULL will get returned.
						yy.cBufP = yy.textPtr + 0

						yy.act = (yyEndOfBuffer + ((yy.start - 1) / 2) + 1)
						goto doAction
					} else {
						if !yy.didBufferSwitchOnEof {
							yy.NewFile()
						}
					}
				case eobActContinueScan:
					yy.cBufP = yy.textPtr + yyAmountOfMatchedText

					yy.currentState = yy.getPreviousState()

					yy.cp = yy.cBufP
					yy.bp = yy.textPtr + 0
					goto yyMatch
				case eobActLastMatch:
					yy.cBufP = yy.nChars

					yy.currentState = yy.getPreviousState()

					yy.cp = yy.cBufP
					yy.bp = yy.textPtr + 0
					goto yyFindAction
				}
			}

		default:
			log.Panicln("fatal flex scanner internal error--no action found:", yy.act)
		} // end of action switch
	} // end of scanning one token
	return nil
} // end of yylex

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
func (yy *Scanner) getNextBuffer() int {

	var numberToMove int
	var retval int

	if yy.cBufP > yy.nChars+1 {
		log.Panic("fatal flex scanner internal error--end of buffer missed")
	}

	if !yy.fillBuffer {
		// Don't try to fill the buffer, so this is an EOF.
		if yy.cBufP-yy.textPtr-0 == 1 {
			// We matched a single character, the EOB, so
			// treat this as a final EOF.
			return eobActEndOfFile
		} else {
			// We matched some text prior to the EOB, first
			// process it.
			return eobActLastMatch
		}
	}

	// Try to read more data.

	// First move last chars to start of buffer.
	numberToMove = yy.cBufP - yy.textPtr - 1

	copy(yy.chBuf, yy.chBuf[yy.textPtr:yy.textPtr+numberToMove])

	if yy.bufferStatus == yyBufferEofPending {
		// don't do the read, it's not guaranteed to return an EOF,
		// just force an EOF
		yy.nChars = 0
		yy.bufNChars = 0
	} else {
		numToRead := yy.bufSize - numberToMove - 1

		for numToRead <= 0 {
			// Not enough room in the buffer - grow it.

			yyCBufPOffset := yy.cBufP

			new_size := yy.bufSize * 2

			if new_size <= 0 {
				yy.bufSize += yy.bufSize / 8
			} else {
				yy.bufSize *= 2
			}

			// Include room in for 2 EOB chars.
			bb := make([]byte, yy.bufSize+2-len(yy.chBuf))
			yy.chBuf = append(yy.chBuf, bb...)

			yy.cBufP = yyCBufPOffset

			numToRead = yy.bufSize - numberToMove - 1

		}

		if numToRead > yyReadBufSize {
			numToRead = yyReadBufSize
		}

		// Read in more data.
		yy.nChars = yy.input(numberToMove, numToRead)
		yy.bufNChars = yy.nChars
	}

	if yy.nChars == 0 {
		if numberToMove == 0 {
			retval = eobActEndOfFile
			yy.Restart(yy.In)
		} else {
			retval = eobActLastMatch
			yy.bufferStatus = yyBufferEofPending
		}
	} else {
		retval = eobActContinueScan
	}

	if yy.nChars+numberToMove > yy.bufSize {
		// Extend the array by 50%, plus the number we really need. *
		newSize := yy.nChars + numberToMove + (yy.nChars >> 1)
		if leng := len(yy.chBuf); leng < newSize {
			chBuf := make([]byte, newSize-leng)
			yy.chBuf = append(yy.chBuf, chBuf...)
		}
	}

	yy.nChars += numberToMove
	yy.bufNChars += numberToMove // TODO: missing in C skel, bug?
	yy.chBuf[yy.nChars] = yyEndOfBufferChar
	yy.chBuf[yy.nChars+1] = yyEndOfBufferChar

	yy.textPtr = 0

	return retval
}

/* yy_get_previous_state - get the state just before the EOB char was reached */
func (yy *Scanner) getPreviousState() int {

	yyCurrentState := yy.currentState
	yyCp := yy.cp

	// [15.0] code to get the start state into yy_current_state goes here --
	/* %% [15.0] code to get the start state into yy_current_state goes here */
	yy.currentState = yy_start_state_list[yy_start]
	// SKEL ----------------------------------------------------------------

	for yy.cp = yy.textPtr + 0; yy.cp < yy.cBufP; yy.cp++ {

		// [16.0] code to find the next state goes here ------------------------
		/* %% [16.0] code to find the next state goes here */
		yy.currentState += yy.currentState[yyIfElse(yy.chBuf[yy.cp] != 0, int(yy.chBuf[yy.cp]), 256)].yy_nxt
		if yy.currentState[-1].yyNxt {
			yy.lastAcceptingState = yy.currentState
			yy.lastAcceptingCpos = yy.cp
		}
		// SKEL ----------------------------------------------------------------

	}
	newCurrentState := yy.currentState
	yy.currentState = yyCurrentState
	yy.cp = yyCp
	return newCurrentState
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
func (yy *Scanner) tryNulTrans(yyCurrentState int) int {

	var yyIsJam bool
	oldCurrentState := yy.currentState
	yy.currentState = yyCurrentState
	yyCp := yy.cp

	// [17.0] code to find the next state, and perhaps do backing up, goes here
	/* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
	yy.cp = yy.cBufP

	yy_c := 256
	transInfo = yy.currentState[yy_c]
	yy.currentState += transInfo.yyNxt
	yyIsJam = trans_Info.yy_Verify != yy_c

	if !yyIsJam {
		if yy.currentState[-1].yyNxt {
			yy.lastAcceptingState = yy.currentState
			yy.lastAcceptingCpos = yy.cp
		}
	}
	// SKEL ----------------------------------------------------------------

	newCurrentState := yy.currentState
	yy.currentState = oldCurrentState
	yy.cp = yyCp

	if yyIsJam {
		return 0
	}
	return newCurrentState
}

func (yy *Scanner) Unput(c byte) {

	yy_bp := yy.textPtr
	yy_cp := yy.cBufP

	// undo effects of setting up yytext
	yy.chBuf[yy_cp] = yy.holdChar

	if yy_cp < 2 {
		// need to shift things up to make room
		// +2 for EOB chars.

		for yy.nChars+2 < yy.bufSize {
			yy.chBuf = append(yy.chBuf, yyEndOfBufferChar)
			yy.bufSize++
		}

		numberToMove := yy.nChars + 2
		moveTo := yy.bufSize + 2 - numberToMove
		copy(yy.chBuf[moveTo:], yy.chBuf[:numberToMove])

		yy_cp += moveTo
		yy_bp += moveTo

		yy.nChars += numberToMove
		yy.bufNChars += numberToMove
	}

	yy_cp--
	yy.chBuf[yy_cp] = c

	// [18.0] update yylineno here -----------------------------------------
	/* %% [18.0] update yylineno here */
	// SKEL ----------------------------------------------------------------

	yy.textPtr = yy_bp
	yy.holdChar = yy.chBuf[yy_cp]
	yy.cBufP = yy_cp
}

func (yy *Scanner) Input() (byte, error) {

	yy.chBuf[yy.cBufP] = yy.holdChar

	if yy.chBuf[yy.cBufP] == yyEndOfBufferChar {
		// yy_c_buf_p now points to the character we want to return.
		// If this occurs *before* the EOB characters, then it's a
		// valid NUL; if not, then we've hit the end of the buffer.
		if yy.cBufP < yy.nChars {
			// This was really a NUL.
			yy.chBuf[yy.cBufP] = 0
		} else {
			// need more input
			offset := yy.cBufP - yy.textPtr
			yy.cBufP++

			switch yy.getNextBuffer() {
			case eobActLastMatch:
				/* This happens because yy_g_n_b()
				 * sees that we've accumulated a
				 * token and flags that we need to
				 * try matching the token before
				 * proceeding.  But for input(),
				 * there's no matching to consider.
				 * So convert the EOB_ACT_LAST_MATCH
				 * to EOB_ACT_END_OF_FILE.
				 */

				/* Reset buffer status. */
				yy.Restart(yy.In)

				fallthrough

			case eobActEndOfFile:
				if yy.Wrap(yy) {
					return 0, io.EOF
				}

				if !yy.didBufferSwitchOnEof {
					yy.Restart(yy.In)
				}

				return yy.Input()

			case eobActContinueScan:
				yy.cBufP = yy.textPtr + offset
			}
		}
	}

	c := yy.chBuf[yy.cBufP]
	yy.chBuf[yy.cBufP] = 0 // preserve yytext
	yy.cBufP++
	yy.holdChar = yy.chBuf[yy.cBufP]

	// [19.0] update BOL and yylineno --------------------------------------
	/* %% [19.0] update BOL and yylineno */
	// SKEL ----------------------------------------------------------------

	return c, nil
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c yyInitial  .
 */
func (yy *Scanner) Restart(input_file io.Reader) {
	yy.initBuffer(input_file)
	yy.loadBufferState()
}

func (yy *Scanner) loadBufferState() {
	yy.nChars = yy.bufNChars
	yy.cBufP = yy.bufPos
	yy.textPtr = yy.cBufP
	yy.In = yy.inputFile
	yy.holdChar = yy.chBuf[yy.cBufP]
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
func (yy *Scanner) initBuffer(file io.Reader) {

	yy.flushBuffer()

	yy.inputFile = file

	yy.fillBuffer = true

	yy.Interactive = yy.IsInteractive(file)

}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
func (yy *Scanner) flushBuffer() {

	yy.bufNChars = 0

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	yy.chBuf[0] = yyEndOfBufferChar
	yy.chBuf[1] = yyEndOfBufferChar

	yy.bufPos = 0

	yy.atBol = 1
	yy.bufferStatus = yyBufferNew

	yy.loadBufferState()
}

func yyIfElse(b bool, i1, i2 int) int {
	if b {
		return i1
	}
	return i2
}

func YYmain(filenames ...string) (interface{}, error) {

	var errval error

	yy := NewScanner()

	if len(filenames) > 0 {
		yy.Filename = filenames[0]
		yy.In, errval = os.Open(yy.Filename)
		if errval != nil {
			return nil, errval
		}
		yy.Wrap = func(yyy *Scanner) bool {
			yyy.In.(*os.File).Close()
			filenames = filenames[1:]
			if len(filenames) == 0 {
				return true
			}
			yyy.Filename = filenames[0]
			yyy.In, errval = os.Open(yyy.Filename)
			if errval != nil {
				return true
			}
			return false
		}
	}

	return yy.Lex(), errval

}

// END OF SKELL --------------------------------------------------------

func main() {
	result, err := YYmain(os.Args[1:]...)
	if err != nil {
		log.Fatal(err)
	}
	if result != nil {
		fmt.Println(result)
	}
	fmt.Println("Done")
}
