// START OF SKELL ------------------------------------------------------
// A lexical scanner generated by flexgo

// [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here

package main

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
)

var toggle = true

const cYY_INT_ALIGNED = "int16"

/* Begin user sect3 */
const cFLEX_DEBUG = false

var IsInteractive = func(file io.Reader) bool { return false }

type yy_state_type int

const cYY_FLEX_LEX_COMPAT = false

var yylineno = 1

// SKEL ----------------------------------------------------------------

const (
	yy_END_OF_BUFFER_CHAR = 0
	INITIAL               = 0

	eob_ACT_END_OF_FILE   = 0
	eob_ACT_CONTINUE_SCAN = 1
	eob_ACT_LAST_MATCH    = 2

	yy_BUFFER_NEW         = 0
	yy_BUFFER_NORMAL      = 1
	yy_BUFFER_EOF_PENDING = 2

	yy_BUF_SIZE      = 32768
	yy_READ_BUF_SIZE = 16384
)

var (
	YYin                io.Reader
	YYout               io.Writer
	YYleng              int
	YYwrap              = func() bool { return true }
	yy_buffer_stack     []*yy_buffer_state
	yy_buffer_stack_top = -1
	yy_c_buf_p          int
	yy_init             = false
	yy_running          bool
	yy_n_chars          int
	yy_start            = 0
	yytext_ptr          int
	yy_hold_char        byte
)

type yy_buffer_state struct {
	yy_input_file io.Reader

	yy_ch_buf  []byte // input buffer
	yy_buf_pos int    // current position in input buffer

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_buf_size int

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	yy_n_chars int

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	yy_is_our_buffer bool

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	yy_is_interactive bool

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	yy_at_bol int

	yy_bs_lineno int /**< The line count. */
	yy_bs_column int /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	yy_fill_buffer bool

	yy_buffer_status int
}

func yy_init_buffer(b *yy_buffer_state, file io.Reader) {

	yy_flush_buffer(b)

	b.yy_input_file = file

	b.yy_fill_buffer = true

	/* If b is the current buffer, then yy_init_buffer was _probably_
	 * called from yyrestart() or through yy_get_next_buffer.
	 * In that case, we don't want to reset the lineno or column.
	 */
	if yy_buffer_stack_top < 0 || b != yy_buffer_stack[yy_buffer_stack_top] {
		b.yy_bs_lineno = 1
		b.yy_bs_column = 0
	}

	b.yy_is_interactive = IsInteractive(file)
}

func yy_flush_buffer(b *yy_buffer_state) {
	if b == nil {
		return
	}
	b.yy_n_chars = 0
	b.yy_ch_buf[0] = yy_END_OF_BUFFER_CHAR
	b.yy_ch_buf[1] = yy_END_OF_BUFFER_CHAR

	b.yy_buf_pos = 0

	b.yy_at_bol = 1
	b.yy_buffer_status = yy_BUFFER_NEW

	if yy_buffer_stack_top >= 0 && b == yy_buffer_stack[yy_buffer_stack_top] {
		yy_load_buffer_state()
	}
}

func yy_create_buffer(file io.Reader, size int) *yy_buffer_state {
	b := yy_buffer_state{
		yy_buf_size:      size,
		yy_ch_buf:        make([]byte, size+2),
		yy_is_our_buffer: true,
	}
	yy_init_buffer(&b, file)
	return &b
}

func yy_MORE_ADJ() int {
	return 0
}

func yy_get_next_buffer() int {

	curbuf := yy_buffer_stack[yy_buffer_stack_top]

	var number_to_move, i int
	var ret_val int

	if yy_c_buf_p > yy_n_chars+1 {
		log.Panic("fatal flex scanner internal error--end of buffer missed")
	}

	if !curbuf.yy_fill_buffer {
		// Don't try to fill the buffer, so this is an EOF.
		if yy_c_buf_p-yytext_ptr-yy_MORE_ADJ() == 1 {
			// We matched a single character, the EOB, so
			// treat this as a final EOF.
			return eob_ACT_END_OF_FILE
		} else {
			// We matched some text prior to the EOB, first
			// process it.
			return eob_ACT_LAST_MATCH
		}
	}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = yy_c_buf_p - yytext_ptr - 1

	for i = 0; i < number_to_move; i++ {
		curbuf.yy_ch_buf[i] = curbuf.yy_ch_buf[i+yytext_ptr]
	}

	if curbuf.yy_buffer_status == yy_BUFFER_EOF_PENDING {
		// don't do the read, it's not guaranteed to return an EOF,
		// just force an EOF
		yy_n_chars = 0
		curbuf.yy_n_chars = 0
	} else {
		num_to_read := curbuf.yy_buf_size - number_to_move - 1

		for num_to_read <= 0 {
			/* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			b := curbuf

			yy_c_buf_p_offset := yy_c_buf_p

			if b.yy_is_our_buffer {
				new_size := b.yy_buf_size * 2

				if new_size <= 0 {
					b.yy_buf_size += b.yy_buf_size / 8
				} else {
					b.yy_buf_size *= 2
				}

				// Include room in for 2 EOB chars.
				bb := make([]byte, b.yy_buf_size+2-len(b.yy_ch_buf))
				b.yy_ch_buf = append(b.yy_ch_buf, bb...)
			} else {
				// Can't grow it, we don't own it.
				b.yy_ch_buf = nil
			}

			if b.yy_ch_buf == nil {
				log.Panicln(
					"fatal error - scanner input buffer overflow")
			}

			yy_c_buf_p = yy_c_buf_p_offset

			num_to_read = curbuf.yy_buf_size - number_to_move - 1

		}

		if num_to_read > yy_READ_BUF_SIZE {
			num_to_read = yy_READ_BUF_SIZE
		}

		// Read in more data.
		yy_n_chars = yy_INPUT(number_to_move, num_to_read)
		curbuf.yy_n_chars = yy_n_chars
	}

	if yy_n_chars == 0 {
		if number_to_move == yy_MORE_ADJ() {
			ret_val = eob_ACT_END_OF_FILE
			YYrestart(YYin)
		} else {
			ret_val = eob_ACT_LAST_MATCH
			curbuf.yy_buffer_status =
				yy_BUFFER_EOF_PENDING
		}
	} else {
		ret_val = eob_ACT_CONTINUE_SCAN
	}

	if yy_n_chars+number_to_move > curbuf.yy_buf_size {
		// Extend the array by 50%, plus the number we really need. *
		new_size := yy_n_chars + number_to_move + (yy_n_chars >> 1)
		if l := len(curbuf.yy_ch_buf); l < new_size {
			b2 := make([]byte, new_size-l)
			curbuf.yy_ch_buf = append(curbuf.yy_ch_buf, b2...)
		}
	}

	yy_n_chars += number_to_move
	curbuf.yy_n_chars += number_to_move // TODO: missing in C skel, bug?
	curbuf.yy_ch_buf[yy_n_chars] = yy_END_OF_BUFFER_CHAR
	curbuf.yy_ch_buf[yy_n_chars+1] = yy_END_OF_BUFFER_CHAR

	yytext_ptr = 0

	return ret_val
}

func yy_load_buffer_state() {
	b := yy_buffer_stack[yy_buffer_stack_top]
	yy_n_chars = b.yy_n_chars
	yy_c_buf_p = b.yy_buf_pos
	yytext_ptr = yy_c_buf_p
	YYin = b.yy_input_file
	yy_hold_char = b.yy_ch_buf[yy_c_buf_p]
}

// [1.5] DFA------------------------------------------------------------
// SKEL ----------------------------------------------------------------

func yy_DO_BEFORE_ACTION(buffer *yy_buffer_state, yy_cp, yy_bp int) {
	yytext_ptr = yy_bp
	// [2.0] code to fiddle yytext and yyleng for yymore() goes here -------
	// SKEL ----------------------------------------------------------------
	YYleng = yy_cp - yy_bp
	yy_hold_char = buffer.yy_ch_buf[yy_cp]
	buffer.yy_ch_buf[yy_cp] = 0
	// [3.0] code to copy yytext_ptr to yytext[] goes here, if %array ------
	// SKEL ----------------------------------------------------------------

	YYtext = buffer.yy_ch_buf[yy_bp:yy_cp]

	yy_c_buf_p = yy_cp
}

// [4.0] data tables for the DFA go here -------------------------------
const yy_batch = 100 // must by zero for interactive scanner
const yy_NUM_RULES = 3
const yy_END_OF_BUFFER = 4

/* This struct is not used in this scanner,
   but its presence is necessary. */
type yy_trans_info struct {
	yy_verify int32
	yy_nxt    int32
}

var yy_acclist = [9]int16{0,
	4, 3, 3, 1, 3, 1, 3, 2,
}

var yy_accept = [12]int16{0,
	1, 1, 1, 2, 3, 4, 6, 8, 8, 9,
	9,
}

var yy_ec = [256]byte{0,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

	1, 3, 1, 1, 1, 1, 1, 1, 1, 1,
	4, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1,
}

var yy_meta = [5]byte{0,
	1, 1, 1, 2,
}

var yy_base = [14]uint16{0,
	7, 0, 9, 11, 0, 11, 0, 0, 11, 11,
	4, 6, 5,
}

var yy_def = [14]int16{0,
	11, 10, 10, 10, 12, 10, 12, 13, 10, 0,
	10, 10, 10,
}

var yy_nxt = [16]uint16{0,
	6, 4, 7, 6, 4, 4, 9, 8, 10, 5,
	3, 10, 10, 10, 10,
}

var yy_chk = [16]int16{0,
	2, 2, 2, 2, 11, 11, 13, 12, 3, 1,
	10, 10, 10, 10, 10,
}

var yy_flex_debug = false

var yy_state_buf = make([]int, 0)
var yy_full_match int
var yy_lp int

var yy_rejected bool

func REJECT() {
	b := yy_buffer_stack[yy_buffer_stack_top]
	b.yy_ch_buf[yy_cp] = yy_hold_char // undo effects of setting up yytext
	yy_cp = yy_full_match             // restore poss. backed-over text
	yy_lp++
	yy_rejected = true
}

var YYtext []byte

// SKEL ----------------------------------------------------------------

func yy_INPUT(offset, max_read int) int {
	// [5.0] fread()/read() definition of YY_INPUT goes here ---------------
	// SKEL ----------------------------------------------------------------
	curbuf := yy_buffer_stack[yy_buffer_stack_top]
	if curbuf.yy_is_interactive {
		b := make([]byte, 1)
		var n int
		for n = 0; n < max_read; n++ {
			nn, err := curbuf.yy_input_file.Read(b)
			if nn < 1 {
				if err != nil && err != io.EOF {
					log.Panicln("input in flex scanner failed:", err)
				}
				break
			}
			curbuf.yy_ch_buf[offset+n] = b[0]
			if b[0] == '\n' {
				n++
				break
			}
		}
		return n
	}

	b := make([]byte, max_read)
	n, err := curbuf.yy_input_file.Read(b)
	if err != nil && err != io.EOF {
		log.Panicln("input in flex scanner failed:", err)
	}
	for i := 0; i < n; i++ {
		curbuf.yy_ch_buf[offset+i] = b[i]
	}
	return n
}

// [6.0] YY_RULE_SETUP definition goes here ----------------------------
func yy_RULE_SETUP(b *yy_buffer_state) {
	if YYleng > 0 {
		if YYtext[YYleng-1] == '\n' {
			b.yy_at_bol = 1
		} else {
			b.yy_at_bol = 0
		}
	}
	//yy_USER_ACTION()
}

// SKEL ----------------------------------------------------------------

var yy_cp int

func YYlex() {
	var yy_current_state int
	var /* yy_cp, */ yy_bp int
	var yy_act int

	if !yy_init {
		yy_init = true

		// #ifdef YY_USER_INIT
		// YY_USER_INIT
		// #endif

		if yy_start == 0 {
			yy_start = 1 /* first start state */
		}

		if YYin == nil {
			YYin = os.Stdin
		}

		if YYout == nil {
			YYout = os.Stdout
		}

		if yy_buffer_stack == nil {
			yy_buffer_stack = make([]*yy_buffer_state, 0, 1)
		}
		if len(yy_buffer_stack) == 0 {
			yy_buffer_stack = append(yy_buffer_stack, yy_create_buffer(YYin, yy_BUF_SIZE))
		}
		yy_buffer_stack_top = len(yy_buffer_stack) - 1

		yy_load_buffer_state()
	}

	{
		// [7.0] user's declarations go here -----------------------------------

		// SKEL ----------------------------------------------------------------

		yy_running = true
		for yy_running { // loops until end-of-file is reached

			buffer := yy_buffer_stack[yy_buffer_stack_top]

			// [8.0] yymore()-related code goes here -------------------------------
			// SKEL ----------------------------------------------------------------

			yy_cp = yy_c_buf_p

			/* Support of yytext. */
			buffer.yy_ch_buf[yy_cp] = yy_hold_char

			// yy_bp points to the position in yy_ch_buf of the start of
			// the current run.
			yy_bp = yy_cp

			// [9.0] code to set up and find next match goes here ------------------
			yy_current_state = yy_start
			yy_current_state += buffer.yy_at_bol

			yy_state_buf = yy_state_buf[0:0]
			yy_state_buf = append(yy_state_buf, yy_current_state)

		yy_match:
			buffer = yy_buffer_stack[yy_buffer_stack_top]
			for {
				yy_c := int(yy_ec[buffer.yy_ch_buf[yy_cp]])
				for int(yy_chk[int(yy_base[yy_current_state])+yy_c]) != yy_current_state {
					yy_current_state = int(yy_def[yy_current_state])
					if yy_current_state >= 11 {
						yy_c = int(yy_meta[yy_c])
					}
				}
				yy_current_state = int(yy_nxt[int(yy_base[yy_current_state])+yy_c])
				yy_state_buf = append(yy_state_buf, yy_current_state)
				yy_cp++
				if yy_current_state == 10 {
					break
				}
			}
			// SKEL ----------------------------------------------------------------

		yy_find_action:
			buffer = yy_buffer_stack[yy_buffer_stack_top]
			// [10.0] code to find the action number goes here ---------------------
			sp := len(yy_state_buf) - 1
			yy_current_state = yy_state_buf[sp]
			yy_state_buf = yy_state_buf[:sp]
			yy_lp = int(yy_accept[yy_current_state])
		find_rule: /* we branch to this label when backing up */
			for { //
				if yy_lp != 0 && yy_lp < int(yy_accept[yy_current_state+1]) {
					yy_act = int(yy_acclist[yy_lp])
					{
						yy_full_match = yy_cp
						break
					}
				}
				yy_cp--

				sp := len(yy_state_buf) - 1
				yy_current_state = yy_state_buf[sp]
				yy_state_buf = yy_state_buf[:sp]

				yy_lp = int(yy_accept[yy_current_state])
			}
			// SKEL ----------------------------------------------------------------

			yy_DO_BEFORE_ACTION(buffer, yy_cp, yy_bp)

			// [11.0] code for yylineno update goes here ---------------------------

			// SKEL ----------------------------------------------------------------

		do_action: // This label is used only to access EOF actions.
			buffer = yy_buffer_stack[yy_buffer_stack_top]

			// [12.0] debug code goes here -----------------------------------------
			// SKEL ----------------------------------------------------------------

			yy_rejected = false
			switch yy_act { // beginning of action switch
			// [13.0] actions go here ----------------------------------------------
			case 1:
				yy_RULE_SETUP(buffer)

				YYout.Write(bytes.ToUpper(YYtext))
			case 2:
				yy_RULE_SETUP(buffer)

				{
					toggle = !toggle
					if toggle {
						YYout.Write([]byte("FOO"))
					} else {
						REJECT()
					}
				}
			case 3:
				yy_RULE_SETUP(buffer)

				ECHO()

			case yy_STATE_EOF(INITIAL):
				YYterminate()
				// SKEL ----------------------------------------------------------------

			case yy_END_OF_BUFFER:
				/* Amount of text matched not including the EOB char. */
				yy_amount_of_matched_text := yy_cp - yytext_ptr - 1

				/* Undo the effects of YY_DO_BEFORE_ACTION. */
				buffer.yy_ch_buf[yy_cp] = yy_hold_char
				//TODO: YY_RESTORE_YY_MORE_OFFSET

				if buffer.yy_buffer_status == yy_BUFFER_NEW {
					/* We're scanning a new file or input source.  It's
					 * possible that this happened because the user
					 * just pointed yyin at a new source and called
					 * yylex().  If so, then we have to assure
					 * consistency between YY_CURRENT_BUFFER and our
					 * globals.  Here is the right place to do so, because
					 * this is the first action (other than possibly a
					 * back-up) that will match for the new input source.
					 */
					yy_n_chars = buffer.yy_n_chars
					buffer.yy_input_file = YYin
					buffer.yy_buffer_status = yy_BUFFER_NORMAL
				}

				/* Note that here we test for yy_c_buf_p "<=" to the position
				 * of the first EOB in the buffer, since yy_c_buf_p will
				 * already have been incremented past the NUL character
				 * (since all states make transitions on EOB to the
				 * end-of-buffer state).  Contrast this with the test
				 * in input().
				 */
				if yy_c_buf_p <= yy_n_chars {
					/* This was really a NUL. */
					var yy_next_state int

					yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text

					yy_current_state = yy_get_previous_state()

					/* Okay, we're now positioned to make the NUL
					 * transition.  We couldn't have
					 * yy_get_previous_state() go ahead and do it
					 * for us because it doesn't know how to deal
					 * with the possibility of jamming (and we don't
					 * want to build jamming into it because then it
					 * will run more slowly).
					 */

					yy_next_state = yy_try_NUL_trans(yy_current_state)

					yy_bp = yytext_ptr + yy_MORE_ADJ()

					if yy_next_state != 0 {
						/* Consume the NUL. */
						yy_c_buf_p++
						yy_cp = yy_c_buf_p
						yy_current_state = yy_next_state
						goto yy_match
					} else {

						// [14.0] code to do back-up for compressed tables and set up yy_cp goes here
						yy_cp = yy_c_buf_p
						// SKEL ----------------------------------------------------------------

						goto yy_find_action
					}

				} else {

					switch yy_get_next_buffer() {
					case eob_ACT_END_OF_FILE:
						yy_did_buffer_switch_on_eof := false

						if YYwrap() {
							// Note: because we've taken care in
							// yy_get_next_buffer() to have set up
							// yytext, we can now set up
							// yy_c_buf_p so that if some total
							// hoser (like flex itself) wants to
							// call the scanner after we return the
							// YY_NULL, it'll still work - another
							// YY_NULL will get returned.
							yy_c_buf_p = yytext_ptr + yy_MORE_ADJ()

							yy_act = yy_STATE_EOF(yy_START())
							goto do_action
						} else {
							if !yy_did_buffer_switch_on_eof {
								yy_NEW_FILE()
							}
						}
					case eob_ACT_CONTINUE_SCAN:
						yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text

						yy_current_state = yy_get_previous_state()

						yy_cp = yy_c_buf_p
						yy_bp = yytext_ptr + yy_MORE_ADJ()
						goto yy_match
					case eob_ACT_LAST_MATCH:
						yy_c_buf_p = yy_n_chars

						yy_current_state = yy_get_previous_state()

						yy_cp = yy_c_buf_p
						yy_bp = yytext_ptr + yy_MORE_ADJ()
						goto yy_find_action
					}
				}

			default:
				log.Panicln("fatal flex scanner internal error--no action found:", yy_act)
			} /* end of action switch */
			if yy_rejected {
				goto find_rule
			}
		} /* end of scanning one token */
	} /* end of user's declarations */

} /* end of yylex */

/* yy_get_previous_state - get the state just before the EOB char was reached */
func yy_get_previous_state() int {

	buffer := yy_buffer_stack[yy_buffer_stack_top]

	var yy_current_state int
	var yy_cp int

	// [15.0] code to get the start state into yy_current_state goes here --
	yy_current_state = yy_start
	yy_current_state += buffer.yy_at_bol

	yy_state_buf = yy_state_buf[0:0]
	yy_state_buf = append(yy_state_buf, yy_current_state)

	// SKEL ----------------------------------------------------------------

	for yy_cp = yytext_ptr + yy_MORE_ADJ(); yy_cp < yy_c_buf_p; yy_cp++ {

		// [16.0] code to find the next state goes here ------------------------
		yy_c := ifelse(buffer.yy_ch_buf[yy_cp] != 0, int(yy_ec[buffer.yy_ch_buf[yy_cp]]), 1)
		for int(yy_chk[int(yy_base[yy_current_state])+yy_c]) != yy_current_state {
			yy_current_state = int(yy_def[yy_current_state])
			if yy_current_state >= 11 {
				yy_c = int(yy_meta[yy_c])
			}
		}
		yy_current_state = int(yy_nxt[int(yy_base[yy_current_state])+yy_c])
		yy_state_buf = append(yy_state_buf, yy_current_state)
		// SKEL ----------------------------------------------------------------

	}
	return yy_current_state
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
func yy_try_NUL_trans(yy_current_state int) int {

	var yy_is_jam bool

	// [17.0] code to find the next state, and perhaps do backing up, goes here

	yy_c := 1
	for int(yy_chk[int(yy_base[yy_current_state])+yy_c]) != yy_current_state {
		yy_current_state = int(yy_def[yy_current_state])
		if yy_current_state >= 11 {
			yy_c = int(yy_meta[yy_c])
		}
	}
	yy_current_state = int(yy_nxt[int(yy_base[yy_current_state])+yy_c])
	if yy_current_state == 10 {
		yy_is_jam = true
	}
	if !yy_is_jam {
		yy_state_buf = append(yy_state_buf, yy_current_state)
	}
	// SKEL ----------------------------------------------------------------

	if yy_is_jam {
		return 0
	}

	return yy_current_state
}

// [18.0] update yylineno here -----------------------------------------
// SKEL ----------------------------------------------------------------

// [19.0] update BOL and yylineno --------------------------------------
// TODO: YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
// SKEL ----------------------------------------------------------------

func yy_START() int {
	return (yy_start - 1) / 2
}

func yy_NEW_FILE() {
	YYrestart(YYin)
}

func yy_STATE_EOF(state int) int {
	return yy_END_OF_BUFFER + state + 1
}

func ECHO() {
	YYout.Write(YYtext)
}

func YYterminate() {
	yy_running = false
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
func YYrestart(input_file io.Reader) {

	if yy_buffer_stack == nil {
		yy_buffer_stack = make([]*yy_buffer_state, 1)
		yy_buffer_stack[0] = yy_create_buffer(YYin, yy_BUF_SIZE)
		yy_buffer_stack_top = 0
	}

	yy_init_buffer(yy_buffer_stack[yy_buffer_stack_top], input_file)
}

func ifelse(b bool, i1, i2 int) int {
	if b {
		return i1
	}
	return i2
}

func YYmain(filenames ...string) {

	if len(filenames) == 0 {
		YYin = os.Stdin
	} else {
		r, err := os.Open(filenames[0])
		if err != nil {
			log.Fatalln(err)
		}
		YYin = r // YYrestart(r) ???
		YYwrap = func() bool {
			r.Close()
			filenames = filenames[1:]
			if len(filenames) == 0 {
				return true
			}
			r, err = os.Open(filenames[0])
			YYin = r
			YYrestart(YYin)
			if err != nil {
				log.Fatalln(err)
			}
			return false
		}
	}

	YYlex()
}

// END OF SKELL --------------------------------------------------------

func main() {
	YYmain(os.Args[1:]...)
	fmt.Println("Done")
}
