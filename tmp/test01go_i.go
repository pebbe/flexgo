//line test01go_i.go:2
// START OF SKELL ------------------------------------------------------
// A lexical scanner generated by flexgo

// [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
/* %% [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
//line test01go.l:1
//line test01go.l:2

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
)



//line test01go_i.go:24

const cYY_INT_ALIGNED = "int16"

/* Begin user sect3 */
const cFLEX_DEBUG = true

type yy_state_type int

const cYY_FLEX_LEX_COMPAT = false

var yylineno = 1

// SKEL ----------------------------------------------------------------

const (
	yy_END_OF_BUFFER_CHAR = 0
	INITIAL               = 0
	YY_BUFSIZE	      = 100000 // buffer size for bufio.Reader, increase this if you get ErrBufferFull

	eob_ACT_END_OF_FILE   = 0
	eob_ACT_CONTINUE_SCAN = 1
	eob_ACT_LAST_MATCH    = 2

	yy_BUFFER_NEW         = 0
	yy_BUFFER_NORMAL      = 1
	yy_BUFFER_EOF_PENDING = 2
)

var (
	YYin                    io.Reader
	YYout                   io.Writer
	YYleng                  int
	YYwrap                  = func() bool { return true }
	yy_buffer_stack         []*yy_buffer_state
	yy_buffer_stack_top     = -1
	yy_c_buf_p              int
	yy_init                 = false
	yy_running              bool
	yy_start                = 0
	yytext_ptr              int
)

type yy_buffer_state struct {
	yy_file   io.Reader
	yy_reader *bufio.Reader

	peek        []byte
	backup      []byte
	eof         bool
	peeked      int
	nul         int
	is_nul      bool
	YY_MORE_ADJ int

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	yy_at_bol int

	yy_bs_lineno int /**< The line count. */
	yy_bs_column int /**< The column count. */

	yy_buffer_status int
}

func (b *yy_buffer_state) yy_n_chars() int {
	var n int
	if b.peek != nil {
		n = len(b.peek)
	}
	if b.backup != nil {
		n += len(b.backup)
	}
	return n
}

func (b *yy_buffer_state) isNul(n int) bool {
	return b.is_nul && b.nul == n
}

func (b *yy_buffer_state) clearNul() {
	b.is_nul = false
}

func (b *yy_buffer_state) YY_DO_BEFORE_ACTION(yy_cp, yy_bp int) {
	yytext_ptr = yy_bp
	b.nul = yy_cp
	b.is_nul = true
	yy_c_buf_p = yy_cp
	YYtext = b.Peeked(yy_cp)
	if yy_bp > 0 {
		if yy_bp < len(YYtext) {
			YYtext = YYtext[yy_bp:]
		} else {
			YYtext = []byte{}
		}
	}
	YYleng = len(YYtext)
}

func (b *yy_buffer_state) Push(bytes []byte) {
	n1 := len(bytes)
	n2 := n1
	if b.backup != nil {
		n2 += len(b.backup)
	}
	bb := make([]byte, n1, n2)
	copy(bb, bytes)
	if n2 > n1 {
		bb = append(bb, b.backup...)
	}
	b.backup = bb
}

func (b *yy_buffer_state) PeekAt(n int) int {
	var pn, bn int
	if b.peek != nil {
		pn = len(b.peek)
	}
	if b.backup != nil {
		bn = len(b.backup)
	}
	if n >= pn+bn && !b.eof {
		var err error
		b.peek, err = b.yy_reader.Peek(n + yy_batch)
		pn = len(b.peek)
		b.eof = false
		if err != nil {
			if err.Error() == "EOF" {
				b.eof = true
			} else {
				log.Panic(err)
			}
		}
	}
	if bn > n {
		return int(b.backup[n])
	}
	n -= bn
	if pn > n {
		return int(b.peek[n])
	}
	return yy_END_OF_BUFFER_CHAR
}

func (b *yy_buffer_state) Peeked(n int) []byte {
	var pn, bn int
	if b.peek != nil {
		pn = len(b.peek)
	}
	if b.backup != nil {
		bn = len(b.backup)
	}
	if i := pn + bn; i < n {
		n = i
	}
	if n <= bn {
		return b.backup[:n]
	}
	if bn == 0 && n <= pn {
		return b.peek[:n]
	}
	bb := make([]byte, bn, n)
	copy(bb, b.backup)
	bb = append(bb, b.peek[:n-bn]...)
	return bb
}

func (b *yy_buffer_state) Advance(n int) {

	if n < 1 {
		return
	}

	if b.backup != nil {
		bn := len(b.backup)
		if n < bn {
			b.backup = b.backup[n:]
			return
		}
		b.backup = nil
		n -= bn
	}

	if n < 1 {
		return
	}

	if b.peek != nil {
		bn := len(b.peek)
		if n < bn {
			b.peek = b.peek[n:]
		} else {
			b.peek = nil
		}
	}

	buf := make([]byte, n)
	_, err := b.yy_reader.Read(buf)
	if err != nil && err != io.EOF {
		log.Panic(err)
	}
}

func yy_init_buffer(b *yy_buffer_state, file io.Reader) {
	if yy_buffer_stack_top < 0 || b != yy_buffer_stack[yy_buffer_stack_top] {
		b.yy_at_bol = 1
		b.yy_bs_lineno = 1
		b.yy_bs_column = 0
	}
	if b.yy_file != file {
		b.yy_file = file
		b.yy_reader = bufio.NewReaderSize(file, YY_BUFSIZE)
		b.backup = b.peek
		b.peek = nil
		b.eof = false
	}
	YYin = file
	yy_c_buf_p = 0
}

func yy_create_buffer(file io.Reader) *yy_buffer_state {
	b := yy_buffer_state{
		yy_file:          file,
		yy_reader:        bufio.NewReaderSize(file, YY_BUFSIZE),
		yy_buffer_status: yy_BUFFER_NEW,
	}
	yy_init_buffer(&b, file)
	return &b
}

func YY_STATE_EOF(state int) int {
	return yy_END_OF_BUFFER + state + 1
}

func yy_get_next_buffer(b *yy_buffer_state) int {

	if yy_c_buf_p > b.yy_n_chars()+1 {
		panic("fatal flex scanner internal error--end of buffer missed")
	}

	if yy_c_buf_p-yytext_ptr-b.YY_MORE_ADJ == 1 {
		/* We matched a single character, the EOB, so
		 * treat this as a final EOF.
		 */
		return eob_ACT_END_OF_FILE
	}

	/* We matched some text prior to the EOB, first
	 * process it.
	 */
	return eob_ACT_LAST_MATCH
}

func yy_load_buffer_state() {
	b := yy_buffer_stack[yy_buffer_stack_top]
	yytext_ptr = 0
	yy_c_buf_p = 0
	YYin = b.yy_file
}

// [1.5] DFA------------------------------------------------------------
/* %% [1.5] DFA */
// SKEL ----------------------------------------------------------------

// [2.0] code to fiddle yytext and yyleng for yymore() goes here -------
/* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here */
// SKEL ----------------------------------------------------------------

// [3.0] code to copy yytext_ptr to yytext[] goes here, if %array ------
/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array */
// SKEL ----------------------------------------------------------------

// [4.0] data tables for the DFA go here -------------------------------
/* %% [4.0] data tables for the DFA go here */
const yy_batch = 0 // must by zero for interactive scanner
const yy_NUM_RULES = 3
const yy_END_OF_BUFFER = 4
/* This struct is not used in this scanner,
   but its presence is necessary. */
type yy_trans_info struct {
	yy_verify int32
	yy_nxt    int32
	}
var yy_accept = [12]int16{   0,
        0,    0,    4,    3,    2,    3,    3,    0,    0,    1,
        0,
    }

var yy_ec = [256]byte{    0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    2,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    3,    4,    1,    1,

        1,    5,    1,    1,    1,    1,    1,    1,    1,    1,
        6,    1,    1,    7,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,
    }

var yy_meta = [8]byte{    0,
        1,    1,    1,    1,    1,    1,    1,
    }

var yy_base = [12]uint16{   0,
        0,    0,   12,   13,   13,    8,    4,    2,    2,   13,
       13,
    }

var yy_def = [12]int16{   0,
       11,    1,   11,   11,   11,   11,   11,   11,   11,   11,
        0,
    }

var yy_nxt = [21]uint16{   0,
        4,    5,    4,    6,    7,    4,    4,   10,   10,    9,
        8,   11,    3,   11,   11,   11,   11,   11,   11,   11,
    }

var yy_chk = [21]int16{   0,
        1,    1,    1,    1,    1,    1,    1,    9,    8,    7,
        6,    3,   11,   11,   11,   11,   11,   11,   11,   11,
    }

var yy_last_accepting_state int
var yy_last_accepting_cpos int
var yy_flex_debug = true

var yy_rule_linenum = [3]int16{   0,
       19,   20,
    }

var YYtext []byte
//line test01go_i.go:379
// SKEL ----------------------------------------------------------------

// [5.0] fread()/read() definition of YY_INPUT goes here ---------------
/* %% [5.0] fread()/read() definition of YY_INPUT goes here */
// SKEL ----------------------------------------------------------------

// [6.0] YY_RULE_SETUP definition goes here ----------------------------
/* %% [6.0] YY_RULE_SETUP definition goes here */
func YY_RULE_SETUP() {
	//YY_USER_ACTION()
}
// SKEL ----------------------------------------------------------------

func YYlex() {
	var yy_current_state int
	var yy_cp, yy_bp int
	var yy_act int

	if !yy_init {
		yy_init = true

		// #ifdef YY_USER_INIT
		// YY_USER_INIT
		// #endif

		if yy_start == 0 {
			yy_start = 1 /* first start state */
		}

		if YYin == nil {
			YYin = os.Stdin
		}

		if YYout == nil {
			YYout = os.Stdout
		}

		if yy_buffer_stack == nil {
			yy_buffer_stack = make([]*yy_buffer_state, 0, 1)
		}
		if len(yy_buffer_stack) == 0 {
			b := yy_create_buffer(YYin)
			yy_buffer_stack = append(yy_buffer_stack, b)
		}
		yy_buffer_stack_top = len(yy_buffer_stack) - 1

		yy_load_buffer_state()
	}

	{
// [7.0] user's declarations go here -----------------------------------
/* %% [7.0] user's declarations go here */
//line test01go.l:17


//line test01go_i.go:435
// SKEL ----------------------------------------------------------------

		yy_running = true
		for yy_running { // loops until end-of-file is reached

			buffer := yy_buffer_stack[yy_buffer_stack_top]

// [8.0] yymore()-related code goes here -------------------------------
/* %% [8.0] yymore()-related code goes here */
// SKEL ----------------------------------------------------------------

			buffer.Advance(yy_c_buf_p)
			yy_c_buf_p = 0
			yy_cp = 0

			/* Support of yytext. */
			buffer.clearNul()

			// yy_bp points to the position in yy_ch_buf of the start of
			// the current run.
			yy_bp = yy_cp

// [9.0] code to set up and find next match goes here ------------------
/* %% [9.0] code to set up and find next match goes here */
		yy_current_state = yy_start
yy_match:
		buffer = yy_buffer_stack[yy_buffer_stack_top]
		for {
			yy_c := int(yy_ec[buffer.PeekAt(yy_cp)])
			if yy_accept[yy_current_state] != 0 {
				yy_last_accepting_state = yy_current_state
				yy_last_accepting_cpos = yy_cp
			}
			for int(yy_chk[int(yy_base[yy_current_state])+yy_c]) != yy_current_state {
				yy_current_state = int(yy_def[yy_current_state])
				if yy_current_state >= 12 {
					yy_c = int(yy_meta[yy_c])
				}
			}
			yy_current_state = int(yy_nxt[int(yy_base[yy_current_state])+yy_c])
			yy_cp++
			if yy_base[yy_current_state] == 13 {
				break
			}
		}
// SKEL ----------------------------------------------------------------

yy_find_action:
			buffer = yy_buffer_stack[yy_buffer_stack_top]
// [10.0] code to find the action number goes here ---------------------
/* %% [10.0] code to find the action number goes here */
		yy_act = int(yy_accept[yy_current_state])
		if yy_act == 0 {
			/* have to back up */
			yy_cp = yy_last_accepting_cpos
			yy_current_state = yy_last_accepting_state
			yy_act = int(yy_accept[yy_current_state])
		}
// SKEL ----------------------------------------------------------------

			buffer.YY_DO_BEFORE_ACTION(yy_cp, yy_bp)

// [11.0] code for yylineno update goes here ---------------------------
/* %% [11.0] code for yylineno update goes here */

// SKEL ----------------------------------------------------------------

do_action:     // This label is used only to access EOF actions.
			buffer = yy_buffer_stack[yy_buffer_stack_top]

// [12.0] debug code goes here -----------------------------------------
/* %% [12.0] debug code goes here */
		if yy_flex_debug {
			if yy_act == 0 {
				fmt.Fprintln(os.Stderr, "--scanner backing up")
			} else if yy_act < 3 {
				fmt.Fprintf(os.Stderr, "--accepting rule at line %d (%q)\n",
				         yy_rule_linenum[yy_act], YYtext)
			} else if yy_act == 3 {
				fmt.Fprintf(os.Stderr, "--accepting default rule (%q)\n", YYtext)
			} else if yy_act == 4 {
				fmt.Fprintln(os.Stderr, "--(end of buffer or a NUL)")
			} else {
				fmt.Fprintf(os.Stderr, "--EOF (start condition %d)\n", yy_START)
			}
		}
// SKEL ----------------------------------------------------------------

			switch yy_act { // beginning of action switch
// [13.0] actions go here ----------------------------------------------
/* %% [13.0] actions go here */
			case 0: /* must back up */
			buffer.clearNul()
			yy_cp = yy_last_accepting_cpos
			yy_current_state = yy_last_accepting_state
			goto yy_find_action
case 1:
YY_RULE_SETUP()
//line test01go.l:19
YYout.Write(bytes.ToUpper(YYtext))
case 2:
YY_RULE_SETUP()
//line test01go.l:20
YYout.Write([]byte("Go"))
case 3:
YY_RULE_SETUP()
//line test01go.l:22
ECHO()
//line test01go_i.go:544
case yy_STATE_EOF(INITIAL):
	YYterminate()
// SKEL ----------------------------------------------------------------

			case yy_END_OF_BUFFER:
				/* Amount of text matched not including the EOB char. */
				yy_amount_of_matched_text := yy_cp - yytext_ptr - 1

				/* Undo the effects of YY_DO_BEFORE_ACTION. */
				buffer.clearNul()
				//TODO: YY_RESTORE_YY_MORE_OFFSET

				if buffer.yy_buffer_status == yy_BUFFER_NEW {
					/* We're scanning a new file or input source.  It's
					 * possible that this happened because the user
					 * just pointed yyin at a new source and called
					 * yylex().  If so, then we have to assure
					 * consistency between YY_CURRENT_BUFFER and our
					 * globals.  Here is the right place to do so, because
					 * this is the first action (other than possibly a
					 * back-up) that will match for the new input source.
					 */
					if buffer.yy_file != YYin {
						buffer.yy_file = YYin
						buffer.yy_reader = bufio.NewReaderSize(YYin, YY_BUFSIZE)
						buffer.peek = nil
						buffer.backup = nil
					}
					buffer.yy_buffer_status = yy_BUFFER_NORMAL
				}

				/* Note that here we test for yy_c_buf_p "<=" to the position
				 * of the first EOB in the buffer, since yy_c_buf_p will
				 * already have been incremented past the NUL character
				 * (since all states make transitions on EOB to the
				 * end-of-buffer state).  Contrast this with the test
				 * in input().
				 */
				if yy_c_buf_p <= buffer.yy_n_chars() {
					/* This was really a NUL. */
					var yy_next_state int

					yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text

					yy_current_state = yy_get_previous_state(buffer)

					/* Okay, we're now positioned to make the NUL
					 * transition.  We couldn't have
					 * yy_get_previous_state() go ahead and do it
					 * for us because it doesn't know how to deal
					 * with the possibility of jamming (and we don't
					 * want to build jamming into it because then it
					 * will run more slowly).
					 */

					yy_next_state = yy_try_NUL_trans(buffer, yy_current_state)

					yy_bp = yytext_ptr + buffer.YY_MORE_ADJ

					if yy_next_state != 0 {
						/* Consume the NUL. */
						yy_c_buf_p++
						yy_cp = yy_c_buf_p
						yy_current_state = yy_next_state
						goto yy_match
					} else {

// [14.0] code to do back-up for compressed tables and set up yy_cp goes here
/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
				yy_cp = yy_c_buf_p
// SKEL ----------------------------------------------------------------
						goto yy_find_action
					}

				} else {

					switch yy_get_next_buffer(buffer) {
					case eob_ACT_END_OF_FILE:
						yy_did_buffer_switch_on_eof := false

						if YYwrap() {
							// Note: because we've taken care in
							// yy_get_next_buffer() to have set up
							// yytext, we can now set up
							// yy_c_buf_p so that if some total
							// hoser (like flex itself) wants to
							// call the scanner after we return the
							// YY_NULL, it'll still work - another
							// YY_NULL will get returned.
							yy_c_buf_p = yytext_ptr + buffer.YY_MORE_ADJ

							yy_act = YY_STATE_EOF(yy_START())
							goto do_action
						} else {
							if !yy_did_buffer_switch_on_eof {
								yy_c_buf_p = 0
								yy_NEW_FILE()
							}
						}
					case eob_ACT_CONTINUE_SCAN:
						// C only
					case eob_ACT_LAST_MATCH:
						yy_c_buf_p = buffer.yy_n_chars()

						yy_current_state = yy_get_previous_state(buffer)

						yy_cp = yy_c_buf_p
						yy_bp = yytext_ptr + buffer.YY_MORE_ADJ
						goto yy_find_action
					}
				}

			default:
				log.Fatalln("fatal flex scanner internal error--no action found:", yy_act)
			} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */

} /* end of yylex */

/* yy_get_previous_state - get the state just before the EOB char was reached */
func yy_get_previous_state(buffer *yy_buffer_state) int {

	var yy_current_state int
	var yy_cp int

// [15.0] code to get the start state into yy_current_state goes here --
/* %% [15.0] code to get the start state into yy_current_state goes here */
	yy_current_state = yy_start
// SKEL ----------------------------------------------------------------

	for yy_cp = yytext_ptr + buffer.YY_MORE_ADJ; yy_cp < yy_c_buf_p; yy_cp++ {

// [16.0] code to find the next state goes here ------------------------
/* %% [16.0] code to find the next state goes here */
		yy_c := ifelse(buffer.isNul(yy_cp), 1, int(yy_ec[buffer.PeekAt(yy_cp)]))
		if yy_accept[yy_current_state] != 0 {
			yy_last_accepting_state = yy_current_state
			yy_last_accepting_cpos = yy_cp
		}
		for int(yy_chk[int(yy_base[yy_current_state])+yy_c]) != yy_current_state {
			yy_current_state = int(yy_def[yy_current_state])
			if yy_current_state >= 12 {
				yy_c = int(yy_meta[yy_c])
			}
		}
		yy_current_state = int(yy_nxt[int(yy_base[yy_current_state])+yy_c])
// SKEL ----------------------------------------------------------------

	}
        return yy_current_state
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
func yy_try_NUL_trans(buffer *yy_buffer_state, yy_current_state int) int {

	var yy_is_jam bool

// [17.0] code to find the next state, and perhaps do backing up, goes here
/* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
	yy_cp := yy_c_buf_p

	yy_c := 1
	if yy_accept[yy_current_state] != 0 {
		yy_last_accepting_state = yy_current_state
		yy_last_accepting_cpos = yy_cp
	}
	for int(yy_chk[int(yy_base[yy_current_state])+yy_c]) != yy_current_state {
		yy_current_state = int(yy_def[yy_current_state])
		if yy_current_state >= 12 {
			yy_c = int(yy_meta[yy_c])
		}
	}
	yy_current_state = int(yy_nxt[int(yy_base[yy_current_state])+yy_c])
	if yy_current_state == 11 {
		yy_is_jam = true
	}
// SKEL ----------------------------------------------------------------

	if yy_is_jam {
		return 0
	}

	return yy_current_state
}

// [18.0] update yylineno here -----------------------------------------
/* %% [18.0] update yylineno here */
// SKEL ----------------------------------------------------------------

// [19.0] update BOL and yylineno --------------------------------------
/* %% [19.0] update BOL and yylineno */
// SKEL ----------------------------------------------------------------

func yy_START() int {
	return (yy_start - 1) / 2
}

func yy_NEW_FILE() {
	YYrestart(YYin)
}

func yy_STATE_EOF(state int) int {
	return yy_END_OF_BUFFER + state + 1
}

func ECHO() {
     YYout.Write(YYtext)
}

func YYterminate() {
     yy_running = false
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
func YYrestart(input_file io.Reader) {

	if yy_buffer_stack == nil {
		yy_buffer_stack = make([]*yy_buffer_state, 1)
		yy_buffer_stack[0] = yy_create_buffer(YYin)
		yy_buffer_stack_top = 0
	}

	yy_init_buffer(yy_buffer_stack[yy_buffer_stack_top], input_file)
}

func ifelse(b bool, i1, i2 int) int {
	if b {
		return i1
	}
	return i2
}

func YYmain(filenames ...string) {

	if len(filenames) == 0 {
		YYin = os.Stdin
 	} else {
                r, err := os.Open(filenames[0])
                if err != nil {
                        log.Fatal(err)
                }
                YYin = r // YYrestart(r) ???
                YYwrap = func() bool {
                        r.Close()
                        filenames = filenames[1:]
                        if len(filenames) == 0 {
                                return true
                        }
                        r, err = os.Open(filenames[0])
                        YYin = r
                        if err != nil {
                                log.Fatal(err)
                        }
                        return false
                }
        }

        YYlex()
}
// END OF SKELL --------------------------------------------------------
//line test01go.l:22



func main() {
	YYmain(os.Args[1:]...)
	fmt.Println("Done")
}

